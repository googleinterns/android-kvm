From 33a780850416ead9d1299faa1c9a4b7ac854eaf6 Mon Sep 17 00:00:00 2001
From: George Popescu <georgepope@google.com>
Date: Tue, 11 Aug 2020 14:58:23 +0000
Subject: [PATCH 06/12] KVM: arm64: UBSAN_BOUNDS can be enabled for both EL1
 and EL2

If an out of bounds happens at EL2, the ubsan_out_of_bounds handler
stores the logging data inside the kvm_ubsan_buffer. The one responsible for
printing is the EL1 ubsan_out_of_bounds handler. The process of
decapsulating the data from the buffer is straightforward.

Signed-off-by: George Popescu <georgepope@google.com>
---
 arch/arm64/include/asm/kvm_debug_buffer.h |  1 +
 arch/arm64/include/asm/kvm_ubsan.h        | 19 ++++++++++++++++++-
 arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c       | 13 ++++++++++++-
 arch/arm64/kvm/kvm_ubsan_buffer.c         | 11 ++++++++++-
 4 files changed, 41 insertions(+), 3 deletions(-)

diff --git a/arch/arm64/include/asm/kvm_debug_buffer.h b/arch/arm64/include/asm/kvm_debug_buffer.h
index d7dcda0ebe0b..1a15ae40e3f5 100644
--- a/arch/arm64/include/asm/kvm_debug_buffer.h
+++ b/arch/arm64/include/asm/kvm_debug_buffer.h
@@ -28,3 +28,4 @@
 	DEFINE_PER_CPU(unsigned long, read_ind) = 0;			\
 	DEFINE_PER_CPU(unsigned long, laps_did) = 0;
 #endif   
+
diff --git a/arch/arm64/include/asm/kvm_ubsan.h b/arch/arm64/include/asm/kvm_ubsan.h
index d2432ba76417..0a1703eee184 100644
--- a/arch/arm64/include/asm/kvm_ubsan.h
+++ b/arch/arm64/include/asm/kvm_ubsan.h
@@ -9,6 +9,23 @@
 #define UBSAN_MAX_TYPE 6
 #define KVM_UBSAN_BUFFER_SIZE 1000
 
+
+struct ubsan_values {
+	void *lval;
+	void *rval;
+	char op;
+};
+
 struct kvm_ubsan_info {
-    int type;
+	enum {
+		UBSAN_OUT_OF_BOUNDS,
+	} type;
+	union {
+		struct out_of_bounds_data out_of_bounds_data;
+	};
+	union {
+		struct ubsan_values u_val;
+	};
 };
+
+void __ubsan_handle_out_of_bounds(void *_data, void *index);
diff --git a/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c b/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c
index 501bd419fb29..2cfdb069a987 100644
--- a/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c
+++ b/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c
@@ -45,7 +45,18 @@ void __ubsan_handle_type_mismatch(struct type_mismatch_data *data,
 
 void __ubsan_handle_type_mismatch_v1(void *_data, void *ptr) {}
 
-void __ubsan_handle_out_of_bounds(void *_data, void *index) {}
+void __ubsan_handle_out_of_bounds(void *_data, void *index)
+{
+	struct kvm_ubsan_info *slot;
+	struct out_of_bounds_data *data = _data;
+
+	slot = kvm_ubsan_buffer_next_slot();
+	if (slot) {
+		slot->type = UBSAN_OUT_OF_BOUNDS;
+		slot->out_of_bounds_data = *data;
+		slot->u_val.lval = index;
+	}
+}
 
 void __ubsan_handle_shift_out_of_bounds(void *_data, void *lhs, void *rhs) {}
 
diff --git a/arch/arm64/kvm/kvm_ubsan_buffer.c b/arch/arm64/kvm/kvm_ubsan_buffer.c
index 12774c5d8bd7..251cf275f1af 100644
--- a/arch/arm64/kvm/kvm_ubsan_buffer.c
+++ b/arch/arm64/kvm/kvm_ubsan_buffer.c
@@ -18,6 +18,15 @@ DECLARE_KVM_DEBUG_BUFFER(struct kvm_ubsan_info, kvm_ubsan_buffer,
 		kvm_ubsan_buff_wr_ind, kvm_ubsan_buff_rd_ind,
 		kvm_ubsan_buff_laps_did, KVM_UBSAN_BUFFER_SIZE);
 
+void __kvm_check_ubsan_data(struct kvm_ubsan_info *slot)
+{
+	switch (slot->type) {
+	case UBSAN_OUT_OF_BOUNDS:
+		__ubsan_handle_out_of_bounds(&slot->out_of_bounds_data,
+				slot->u_val.lval);
+		break;
+	}
+}
 
 void iterate_kvm_ubsan_buffer(int left, int right, unsigned long *nr_slots) {
 	unsigned int i;
@@ -25,7 +34,7 @@ void iterate_kvm_ubsan_buffer(int left, int right, unsigned long *nr_slots) {
 	struct kvm_ubsan_info *slot;
 	slot = (struct kvm_ubsan_info *) this_cpu_ptr_nvhe(kvm_ubsan_buffer);
 	for (i = left; i <= right && *nr_slots > 0; ++i, --*nr_slots) {
-		/* check ubsan data */
+		__kvm_check_ubsan_data(slot);
 		/* clear the slot */
 		slot[i].type = 0;
 	}
-- 
2.28.0.220.ged08abb693-goog

