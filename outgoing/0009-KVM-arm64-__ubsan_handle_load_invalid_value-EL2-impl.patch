From 7a676fcb0e01c4d2cbc30479b075d21e8c5f564a Mon Sep 17 00:00:00 2001
From: George Popescu <georgepope@google.com>
Date: Mon, 10 Aug 2020 15:38:22 +0000
Subject: [PATCH 09/12] KVM: arm64: __ubsan_handle_load_invalid_value EL2
 implementation.

The handler for the load invalid value undefined behaviour is
implemented at EL2. The EL2 handler's parameters are stored inside the buffer.
They are used by the symetric handler from EL1.

Signed-off-by: George Popescu <georgepope@google.com>
---
 arch/arm64/include/asm/kvm_ubsan.h  |  5 ++++-
 arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c | 13 ++++++++++++-
 arch/arm64/kvm/kvm_ubsan_buffer.c   |  4 ++++
 3 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/arch/arm64/include/asm/kvm_ubsan.h b/arch/arm64/include/asm/kvm_ubsan.h
index 64a6e8c005b2..116804b1869f 100644
--- a/arch/arm64/include/asm/kvm_ubsan.h
+++ b/arch/arm64/include/asm/kvm_ubsan.h
@@ -20,12 +20,14 @@ struct kvm_ubsan_info {
     enum {
         UBSAN_OUT_OF_BOUNDS,
         UBSAN_UNREACHABLE_DATA,
-        UBSAN_SHIFT_OUT_OF_BOUNDS
+        UBSAN_SHIFT_OUT_OF_BOUNDS,
+        UBSAN_INVALID_DATA
     } type;
     union {
         struct out_of_bounds_data out_of_bounds_data;
         struct unreachable_data unreachable_data;
         struct shift_out_of_bounds_data shift_out_of_bounds_data;
+        struct invalid_value_data invalid_value_data;
     };
     union {
         struct ubsan_values u_val;
@@ -35,3 +37,4 @@ struct kvm_ubsan_info {
 void __ubsan_handle_out_of_bounds(void *_data, void *index);
 void __ubsan_handle_builtin_unreachable(void *_data);
 void __ubsan_handle_shift_out_of_bounds(void *_data, void *lhs, void *rhs);
+void __ubsan_handle_load_invalid_value(void *_data, void *val);
diff --git a/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c b/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c
index 92b2fad00e84..d43fe562d2be 100644
--- a/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c
+++ b/arch/arm64/kvm/hyp/nvhe/kvm_ubsan.c
@@ -84,4 +84,15 @@ void __ubsan_handle_builtin_unreachable(void *_data)
 	}
 }
 
-void __ubsan_handle_load_invalid_value(void *_data, void *val) {}
+void __ubsan_handle_load_invalid_value(void *_data, void *val){
+	struct kvm_ubsan_info *slot;
+	struct invalid_value_data *data = _data;
+
+	slot = kvm_ubsan_buffer_next_slot();
+	if (slot) {
+		slot->type = UBSAN_INVALID_DATA;
+		slot->invalid_value_data = *data;
+		slot->u_val.lval = val;
+	}
+
+}
diff --git a/arch/arm64/kvm/kvm_ubsan_buffer.c b/arch/arm64/kvm/kvm_ubsan_buffer.c
index 9bd736c9b618..d00a9c07b224 100644
--- a/arch/arm64/kvm/kvm_ubsan_buffer.c
+++ b/arch/arm64/kvm/kvm_ubsan_buffer.c
@@ -32,6 +32,10 @@ void __kvm_check_ubsan_data(struct kvm_ubsan_info *slot)
         	__ubsan_handle_shift_out_of_bounds(&slot->shift_out_of_bounds_data,
 				slot->u_val.lval, slot->u_val.rval);
         	break;
+	case UBSAN_INVALID_DATA:
+        	__ubsan_handle_load_invalid_value(&slot->invalid_value_data,
+				slot->u_val.lval);
+		break;
     	}
 }
 
-- 
2.28.0.220.ged08abb693-goog

